{"data":{"allBlogJson":{"edges":[{"node":{"title":["A quick intro to async/await in Javascript"],"pubDate":["Thu, 10 May 2018 11:07:21 GMT"],"link":["https://medium.com/@anuhosad/a-quick-intro-to-async-await-in-javascript-64dff152a19d?source=rss-bc5490c02ddb------2"],"id":"3f4acc61-6b40-5bc5-9538-d4141917229a","content_encoded":["<p>async/await is the latest addition to the language that helps in writing better asynchronous code. It is part of the 8th Edition of ECMAScript (called ES8 or ES2017).</p><p>Before we jump into the details of async/await, let us go back in time to revisit the various approaches to asynchronous programming in javascript.</p><p>Lets take the hypothetical case of customers at a coffee shop. A customer goes up to the counter and orders coffee. They get a token in return for the order and probably go and take a seat at the coffee shop, reading their newspapers or phones or maybe chatting with a friend while they wait for their coffee. Once the coffee is done, the customer gets a notification that their coffee is ready and they go pick it up. While the customer is waiting for his coffee, the person at the counter takes order from the other customers in the queue.<br>The entire process is asynchronous here. The customer orders coffee and then goes back to doing something. The person at the counter takes other orders meanwhile. So waiting for one customer’s coffee to be done does not block the other customers waiting in queue.</p><p>Lets see how to implement this in javascript with the various available features.</p><ol><li><strong>Callback Pattern</strong></li></ol><p>This is one of the basic patterns used to achieving asynchronous behaviour in javascript that works across all environments. In this pattern a function is passed onto the function doing the asynchronous task. Once the asynchronous task is done, the passed function gets called (which is called the callback function).</p><p>Implementing the code for the above problem with callback function would look as follows:</p><pre>function serveCoffee () {<br>    console.log(&quot;Yay! your coffee is done, enjoy!&quot;);<br>}</pre><pre>function makeCoffee (callbackFn) {<br>    /* Simulating coffee making using setTimeout */<br>    setTimeout(function () {<br>       callbackFn();<br>    }, 5000);<br>}</pre><pre>function handleCoffeeOrder () {<br>    /* send request to make the coffee,<br>       serveCoffee is the callback function that gets called once the coffee is ready */<br>    makeCoffee(serveCoffee); <br>}</pre><pre>handleCoffeeOrder(); /* handle coffee order from a customer */</pre><p>In the code above, serveCoffee is the callback function that gets called once the coffee is prepared.</p><p>This pattern gets messy with nested asynchronous calls. The problem is often referred to as <em>callback hell</em> or <em>Christmas tree problem</em> ( because it kind of looks like a fallen down Christmas tree!)</p><pre>doAsyncTask1(function() {<br>  doAsyncTask2(function() {<br>    doAsyncTask3(function() {<br>      doAsyncTask4(function() {<br>        console.log(&quot;Finally Done!&quot;);<br>      });<br>    });<br>  });<br>});</pre><p><strong>2. Promises</strong></p><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promises</a> was introduced in ES6 (or ES2015). This provided a better mechanism to handle asynchronous tasks than using callbacks.</p><p>Implementing the solution for the coffee task using promises would be as follows:</p><pre>function makeCoffee (onCoffeeDone) {<br>    <strong>return new Promise(resolve, reject) {</strong><br>        /* Simulating coffee making using setTimeout */<br>        setTimeout(function() {<br>            <strong>resolve(&quot;success&quot;);</strong><br>        }, 2000);<br>    <strong>};</strong><br>}</pre><pre>function handleCoffeeOrder () {<br>    makeCoffee()<br>    .then(function () {<br>        serveCoffee();<br>    });<br>}</pre><pre>handleCoffeeOrder();</pre><p>Here, in the makeCoffee function, a Promise object is created and returned. Once the task is done (here it is preparing the coffee), resolve function is called which indicates that the task is done successfully. Once the promise is resolved, code in the then block gets executed.</p><p>The above code looks a little neater than the callback pattern code and is easier to reason with.</p><p>The nested asynchronous calls problem looks like below with promises:</p><pre>doAsyncTask1().then(function () {<br>   return doAsyncTask2();<br>}).then(function () {<br>   return doAsyncTask3();<br>}).then(function () {<br>   return doAsyncTask4();<br>}).then(function () {<br>   console.log(&quot;Finally Done!&quot;);<br>});</pre><p><strong>3. async/await</strong></p><p>The same logic above can be written as shown below with async/await:</p><pre>function makeCoffee (onCoffeeDone) {<br>    return new Promise(resolve, reject) {<br>        /* Simulating coffee making using setTimeout */<br>        setTimeout(function () {<br>            resolve(&quot;success&quot;);<br>        }, 2000);<br>    };<br>}</pre><pre><strong>async</strong> function handleCoffeeOrder () {<br>   let response = <strong>await</strong> makeCoffee();<br>   serveCoffee();<br>}</pre><pre>handleCoffeeOrder();</pre><p>To begin with, any function that is asynchronous should be marked with the <strong>async</strong> keyword. You can then use the <strong>await</strong> keyword to wait for an asynchronous task (i.e. any function that returns a Promise). What this essentially does is pauses the function execution until the asynchronous task finishes. However, the rest of the Javascript execution continues and is not blocked. That means in this case, while “awaiting” for one customer’s coffee to be done, the person at the counter can take in more orders and make more requests for coffee.</p><p>One thing to note here is that a function marked async also returns a Promise which gets resolved when the function completes execution and returns a value.</p><p>The nested asynchronous calls problem looks like below with async/await:</p><pre>async function performAsyncTasks () {<br>   await doAsyncTask1();<br>   await doAsyncTask2();<br>   await doAsyncTask3();<br>   await doAsyncTask4();<br>   console.log(&quot;Finally Done!&quot;);<br>}</pre><p>As seen from the code above, async/await provides a much cleaner way to write asynchronous code in a “synchronous looking” manner. The number of lines of code is also much lesser than using promises or callback functions.</p><p>Finally, here is the current browser support matrix for async/await :</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*9hOlRmx9ZefDMCMQERHUbg.png\" /><figcaption><strong>Reference:</strong> <a href=\"https://caniuse.com/#search=await\">https://caniuse.com/#search=await</a></figcaption></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=64dff152a19d\" width=\"1\" height=\"1\">"]}},{"node":{"title":["Circular progress bars using Canvas tag"],"pubDate":["Thu, 07 Jun 2018 04:16:01 GMT"],"link":["https://medium.com/@anuhosad/circular-progress-bars-using-canvas-tag-ec36cdd107e1?source=rss-bc5490c02ddb------2"],"id":"76ac97eb-a01b-5c7c-a776-d8fa3e7bd146","content_encoded":["<p>This tutorial is aimed at creating filled circular progress bars using Canvas tag like the ones shown below:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/804/1*J1FCzF9BGhdRp8IR_Lvp7w.jpeg\" /></figure><p>Before jumping into the code, we need to understand how to draw a circle using Canvas tag.</p><p>For the purposes of the Canvas tag, the circle is represented as follows:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/592/1*6tHkGnGJb_yfFo1krzzZng.png\" /></figure><p>So, with this in mind, to draw a circle using Canvas tag we can use the following code:</p><p><strong>HTML</strong></p><pre>&lt;canvas width=&quot;150&quot; height=&quot;150&quot; id=&quot;canvas&quot; /&gt;</pre><p><strong>JS</strong></p><pre>let canvas = document.getElementById(&quot;canvas&quot;);<br>let context = canvas.getContext(&quot;2d&quot;);<br>let centerX = canvas.width / 2;<br>let centerY = canvas.height / 2;<br>let radius = 70;<br>    <br>/* draw the circle */ </pre><pre>/* begin the path */<br>context.beginPath();</pre><pre>/* move to the center of the circle */<br>context.moveTo(centerX, centerY); </pre><pre>/* draw arc from 0 to 2 * Math.PI which is equivalent to 360 deg */<br>context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);</pre><pre>/* close the path */<br>context.closePath();</pre><pre>/* fill it with grey color */<br>context.fillStyle = &quot;#ddd&quot;;<br>context.fill();</pre><pre>/* give a border to the circle */<br>context.strokeStyle = &quot;rgba(200, 208, 218, 0.66)&quot;;<br>context.stroke();</pre><p>The above code draws a grey circle. Now to show the green progress circle based on the progress percentage, we would write the following code:</p><pre>/* startAngle is from 0 deg which is 1.5 * Math.PI (refer to the diagram above) */<br>let startAngle = 1.5 * Math.PI;</pre><pre>/* calculate the value of one unit on the circle */<br>let unitValue = (Math.PI - 0.5 * Math.PI) / 25;</pre><pre>/* find the end angle based on the start angle */<br>if (percent &gt;= 0 &amp;&amp; percent &lt;= 25) {<br> endAngle = startAngle + (percent * unitValue);<br>} else if (percent &gt; 25 &amp;&amp; percent &lt;= 50) {<br> endAngle = startAngle + (percent * unitValue);<br>} else if (percent &gt; 50 &amp;&amp; percent &lt;= 75) {<br> endAngle = startAngle + (percent * unitValue);<br>} else if (percent &gt; 75 &amp;&amp; percent &lt;= 100) {<br> endAngle = startAngle + (percent * unitValue);<br>}<br>    <br>/* draw the green circle */<br>context.beginPath();<br>context.moveTo(centerX, centerY);<br>context.arc(centerX, centerY, radius, startAngle, endAngle, false);<br>context.closePath();<br>context.fillStyle = &quot;#2cb191&quot;;<br>context.fill();</pre><p>This draws the green progress circle.</p><p>The complete code is as shown below:</p><pre>function drawProgressCircle (percent) {<br>  let canvas = document.getElementById(&quot;canvas&quot;);<br>  let context = canvas.getContext(&quot;2d&quot;);<br>  let centerX = canvas.width / 2;<br>  let centerY = canvas.height / 2;<br>  let radius = 70;<br>    <br>  /* draw the grey circle */ <br>  context.beginPath();<br>  context.moveTo(centerX, centerY); <br>  context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);<br>  context.closePath();<br>  context.fillStyle = &quot;#ddd&quot;;<br>  context.fill();<br>  context.strokeStyle = &quot;rgba(200, 208, 218, 0.66)&quot;;<br>  context.stroke();<br>  <br>  /* draw the green circle based on percentage */<br>  let startAngle = 1.5 * Math.PI;<br>  let unitValue = (Math.PI - 0.5 * Math.PI) / 25;<br>  if (percent &gt;= 0 &amp;&amp; percent &lt;= 25) {<br>     endAngle = startAngle + (percent * unitValue);<br>  } else if (percent &gt; 25 &amp;&amp; percent &lt;= 50) {<br>     endAngle = startAngle + (percent * unitValue);<br>  } else if (percent &gt; 50 &amp;&amp; percent &lt;= 75) {<br>     endAngle = startAngle + (percent * unitValue);<br>  } else if (percent &gt; 75 &amp;&amp; percent &lt;= 100) {<br>   endAngle = startAngle + (percent * unitValue);<br>  }<br>    <br>  context.beginPath();<br>  context.moveTo(centerX, centerY);<br>  context.arc(centerX, centerY, radius, startAngle, endAngle, false);<br>  context.closePath();<br>  context.fillStyle = &quot;#2cb191&quot;;<br>  context.fill();<br>}</pre><pre>drawProgressCircle(80);</pre><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ec36cdd107e1\" width=\"1\" height=\"1\">"]}},{"node":{"title":["Debouncing events with React"],"pubDate":["Sun, 03 Feb 2019 16:08:25 GMT"],"link":["https://medium.com/@anuhosad/debouncing-events-with-react-b8c405c33273?source=rss-bc5490c02ddb------2"],"id":"a681dbe6-d048-511e-9c15-9960c1e69f33","content_encoded":["<p>I recently came across a use case in the project I am working on where I had to debounce the input onChange event callback.</p><p>A common use case is when you have an input element like below which functions as a search input in your app.</p><pre>&lt;input name=&quot;search-input&quot; onChange={this.onChange} /&gt;</pre><p>If you are making API calls to fetch the search data as shown below, then, to make it performant you should not make the API call for every character that is input by the user, but only after the user input stops for some milliseconds.</p><pre>onChange = (event) =&gt; {<br>    let searchString = event.target.value;<br>    fetchSearchData(searchString);<br>}</pre><p>This is easily achieved by using a debounce function. Below I am using the debounce function from the lodash library:</p><pre>&lt;input onChange={_.debounce(this.onChange, 300)} /&gt;</pre><p>The above code passes a debounced function as the event callback to the onChange event. The _.debounce function ensures that the actual onChange event callback is called only when the user has stopped inputting the characters for 300ms.</p><p>But doing this in a React application throws the following error:</p><blockquote><strong>Warning: This synthetic event is reused for performance reasons.<em> </em>If you’re seeing this, you’re accessing the property `target` on a released/nullified synthetic event.</strong></blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*4-KsyAFHHgE8sPk3uS9JXQ.png\" /><figcaption>Error in the console</figcaption></figure><p>This error is thrown because React does <a href=\"https://reactjs.org/docs/events.html#event-pooling\"><strong>event pooling</strong></a><strong>. </strong>This means that the event object (which is a wrapper created by React over the actual event object) that is passed to an event callback is reused and hence it will be nullified or cleared once the event callback finishes. So accessing event.target.value in the example above throws an error because event object was nullified when the event callback finished and we are trying to access it later (after 300ms in this example) through the debounce function.</p><p>To fix this issue, we need to tell React that the event object will be used in the future and hence should not be nullified. This is done by calling the persist() method on React’s synthetic event object.</p><p>So we have to rewrite the onChange event handler as shown below to make it work with debounce:</p><pre>onChange = (event) =&gt; {<br>    /* signal to React not to nullify the event object */<br>    event.persist();<br>    <br>    if (!this.debouncedFn) {<br>      this.debouncedFn =  _.debounce(() =&gt; {<br>         let searchString = event.target.value;<br>         fetchSearchData(searchString);<br>      }, 300);<br>    }</pre><pre>    this.debouncedFn();<br>}</pre><pre><br>// in render method</pre><pre>&lt;input name=&quot;search-input&quot; onChange={this.onChange} /&gt;</pre><p>That’s it folks! Happy Reacting :-)</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b8c405c33273\" width=\"1\" height=\"1\">"]}},{"node":{"title":["Creating true immutable values in Javascript"],"pubDate":["Mon, 16 Jul 2018 13:25:10 GMT"],"link":["https://medium.com/@anuhosad/creating-true-immutable-values-in-javascript-65041209b87?source=rss-bc5490c02ddb------2"],"id":"44dc335c-b687-5d3e-84ee-bf39e78b8b00","content_encoded":["<p>ES6 introduced a new declaration called const for declaring variables as holding constant (i.e. immutable) values.</p><p>Here is the definition of const from the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const\">MDN web docs</a>.</p><blockquote>Constants are block-scoped, much like variables defined using the let statement. The value of a constant cannot change through re-assignment, and it can&#39;t be redeclared.</blockquote><p>What this means is that if you declare a variable as const, it becomes a read only value and you cannot change its value after the initial assignment. Doing so would throw an error as shown below:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*J5rpdvpr1EVpoWB7RFZy_g.png\" /><figcaption>Error when changing a “const” value</figcaption></figure><p>But an interesting thing happens when we declare an object as a const value.<br>Though you cannot change the object value, you can still update its property values!</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5c1apn8B51z0Wl_ELCTsEg.png\" /><figcaption>Declaring Object as “const”</figcaption></figure><p>As seen in the above image, the variable called stationaryBox is declared as a const. So, when you try to replace the object value, it gives you an error. However you can still access the property values of the object (like pencils key in the above example) and update them individually. The same thing happens when declaring an array as const .</p><p>Then how can you truly prevent an object from being updated ?</p><p>There are a couple of ways to do that in conjunction with const declaration:</p><p><strong>1)</strong> <strong>Using object property descriptors</strong></p><p>Every object property is defined by 3 descriptors:<br><em>a) enumerable</em> : if true, property will be listed in loops <br><em>b) writable</em> : if true, property value can be changed<br><em>c) configurable</em> : if true, property descriptors can be changed</p><p>So we can prevent an object from being updated by setting the descriptor value to writable:false, configurable: false for all the object properties as shown below:</p><pre>const stationaryBox = {<br>  pencils: 2,<br>  pens: 3,<br>  eraser: 1<br>};</pre><pre>Object.defineProperties(stationaryBox, {<br>  pencils: {enumerable: true, writable: false, configurable: false},<br>  pens: {enumerable: true, writable: false, configurable: false},<br>  eraser: {enumerable: true, writable: false, configurable: false}<br>});</pre><p><strong>2) Using Object.freeze()</strong></p><p>Instead of setting writable: false, configurable: false on every property, there is an Object method called freeze() that you can use which does the exact same thing as above on all object properties.</p><pre>const stationaryBox = {<br>  pencils: 2,<br>  pens: 3,<br>  eraser: 1<br>};</pre><pre>Object.freeze(stationaryBox);</pre><p>If you instead want to just prevent adding new properties, you can use Object.preventExtensions(obj) . To prevent both addition and removal of properties you can use Object.seal(obj) .</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=65041209b87\" width=\"1\" height=\"1\">"]}},{"node":{"title":["HTML5 Video Pre-buffering on Mobile"],"pubDate":["Mon, 21 May 2018 10:16:31 GMT"],"link":["https://medium.com/@anuhosad/html5-video-pre-buffering-on-mobile-a8fbdd358993?source=rss-bc5490c02ddb------2"],"id":"b3684e84-0cc3-5a03-ba70-62afdb5eaa25","content_encoded":["<h3><strong>The Problem:</strong></h3><p>Pre-buffering a HTML5 video resource on a mobile browser or a mobile webview is a herculean task. This is because the standard preload attribute on the HTML5 &lt;video&gt; tag is ignored or disabled by mobile browser vendors to save on the data costs to the user.</p><p>Here is the definition of the preload attribute from the <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video\">MDN web docs</a>:</p><blockquote><strong>preload</strong>This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience. It may have one of the following values:</blockquote><blockquote>none: indicates that the video should not be preloaded.</blockquote><blockquote>metadata: indicates that only video metadata (e.g. length) is fetched.</blockquote><blockquote>auto: indicates that the whole video file could be downloaded, even if the user is not expected to use it.</blockquote><blockquote>the <em>empty string</em>: synonym of the auto value.</blockquote><p>Hence, the preload attribute is only a hint to the browser to preload the video resource and not a mandate. In mobile devices, the video does not start downloading until the user initiates playback.</p><p>But, what if your task at hand requires you to show a buffer free, instant playing video experience to your users? Here we discuss some possible workarounds to solve this problem.</p><p>The below techniques assume the following video tag in your HTML</p><pre>&lt;video id=&quot;video&quot; src=&quot;<a href=\"http://techslides.com/demos/sample-videos/small.mp4\">http://techslides.com/demos/sample-videos/small.mp4</a>&quot; controls /&gt;</pre><h3><strong>The (possible) solutions:</strong></h3><p><strong>1)</strong> <strong>Using </strong><strong>XMLHttpRequest to preload the entire video</strong></p><p>You can make an ajax call to fetch the entire video as a blob and then append the resultant video URL created usingURL.createObjectUrl() to the video tag as show below:</p><pre>var request = new XMLHttpRequest();</pre><pre>request.open(&quot;GET&quot;, &quot;<a href=\"http://techslides.com/demos/sample-videos/small.mp4\">http://techslides.com/demos/sample-videos/small.mp4</a>&quot;, true);</pre><pre>/* set the response to blob type */<br>request.responseType = &quot;blob&quot;;</pre><pre>request.onload = function () {<br>  if (this.status === 200) {<br>     var videoBlob = this.response;<br>     /* create the video URL from the blob */<br>     var videoUrl = URL.createObjectURL(videoBlob);<br>     /* set the video URL as source on the video element */<br>     video.src = videoUrl;<br>  }<br>}</pre><pre>request.send();</pre><p>Using this technique the entire video has to be downloaded before you can use it. The other drawback is that you can only download videos from the same domain or from domains that have allowed cross origin access on the resource. Otherwise you will get cross domain resource sharing issues as shown below:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*8gQG2Z5MeqnvshZfIzJOfA.png\" /><figcaption>Cross domain resource access issues</figcaption></figure><p><strong>2)</strong> <strong>Using </strong><strong>load() and </strong><strong>play() methods</strong></p><p>Call video.load() method that triggers the loading of the video before you land on the page / view that is showing the video. Once the video comes into view call video.play() method.<br>This method works only on iOS and does not work in android.</p><p><strong>3) Playing a muted video in the background</strong></p><p>First mute the video with video.muted = true. Then call video.play() method, to start the video playback before you land on the page / view that is showing the video. Once the video comes into view call video.pause() function to pause the video and reset the video to the beginning using video.currentTime = 0 .</p><p>You can also try the same technique as above by setting the autoplay attribute on the video tag instead of calling video.play() method.</p><p><strong>4) Playing a muted video with </strong><strong>timeupdate event</strong></p><p>Call video.play() before the video is shown and on video timeupdate event, when video.currentTime &gt; 0, call video.pause() method and reset the video to the beginning using video.currentTime = 0. The video will then continue to load in the background.</p><p>Solutions 2–4 help you to partially or fully preload the video.</p><p>All the above techniques help you to pre-buffer a video on mobile browsers and webviews. You can choose whichever one best suits your needs.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a8fbdd358993\" width=\"1\" height=\"1\">"]}},{"node":{"title":["Quick Tip : Garbage Collection Gotcha in V8 Engine"],"pubDate":["Thu, 10 May 2018 11:48:30 GMT"],"link":["https://medium.com/@anuhosad/quick-tip-garbage-collection-gotcha-in-v8-engine-57558d0e5749?source=rss-bc5490c02ddb------2"],"id":"7c0b26f0-e3b4-507a-a6a6-8dab91e713c0","content_encoded":["<p>Have you ever come across a variable that was undefined or not available when inspecting with the debugger in Chrome developer tools ? Or, maybe the variable contained a value that you did not expect ?</p><p>Before you think there is a bug in your application logic and spend hours debugging it, wait! Just read further to understand why this happens!</p><p>The V8 engine (which is the Javascript engine in Chrome browser), does a garbage collection of variables that are no longer used and hence some variables might not be available or might have a different value than expected when you are debugging it using Chrome debugger. This is an optimization that is done by the V8 engine which is a feature and not a bug ;-)</p><p>What you can do in such cases is to just console.log the variable whose value you want to inspect instead of checking via the debugger.</p><p>Hope this saved some time that you might have spent in debugging an issue that is actually not a issue!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=57558d0e5749\" width=\"1\" height=\"1\">"]}},{"node":{"title":["Porting Medium articles to create a blog in Gatsby"],"pubDate":["Sun, 13 Oct 2019 16:01:11 GMT"],"link":["https://medium.com/@anuhosad/porting-medium-articles-to-create-a-blog-in-gatsby-749c0932523f?source=rss-bc5490c02ddb------2"],"id":"aa8ab202-f138-52b4-b11a-fd146ec4e390","content_encoded":["<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/501/1*WBV4y6b5n1Lgx5zFtbnUTQ.jpeg\" /></figure><p>I recently built my <a href=\"http://anupamahosad.com\">personal website</a> using Gatsby JS. The logical next step was to add a blog section where I wanted to display all the articles that I had written on Medium.</p><p>While I wanted to continue writing on Medium as it gives a great writing &amp; publishing platform, I also wanted to display the Medium articles on my website as well.</p><p>But to burst my bubble, I found out through <a href=\"https://twitter.com/reeversedev/status/1180899955407376386\">this</a> twitter thread that Medium does not provide an easy to use API to pull all the articles from Medium. Though I got a few suggestions to make this work, I wanted to try something new.</p><p>This is how I ended up accomplishing the task!</p><ol><li><strong>Node script to pull RSS feed from Medium &amp; convert it to JSON</strong></li></ol><p>I wrote a simple node script to fetch the Medium RSS feed which is in XML format. The RSS feed URL for an account would look something like https://medium.com/feed/&lt;username&gt;</p><p>In this RSS feed, there would be an &lt;item&gt; tag for each of the articles posted on medium by the username provided in the URL. It would look something like this:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*MHNYV3lxYga-x5E60ad4cg.png\" /></figure><p>After fetching this RSS feed, I converted the XML to JSON using <a href=\"https://www.npmjs.com/package/xml2js\">xml2js</a> npm package and wrote the resulting JSON for each of the articles in their respective files under content/blog/ directory in my main project directory.</p><p>The complete node script for this can be found <a href=\"https://github.com/AnupamaHosad/website/blob/master/medium.js\">here</a>.</p><p><strong>2. Inject JSON data from the file into a component using Gatsby filesystem plugin</strong></p><p>Next, I used the <a href=\"https://www.gatsbyjs.org/packages/gatsby-source-filesystem/\">gatsby-source-filesystem</a> plugin to source each article’s JSON data that is now present in my file system under content/blog/ directory into my Gatsby application. I also had to use the <a href=\"https://www.gatsbyjs.org/packages/gatsby-transformer-json/\">gatsby-transformer-json</a> plugin to convert the JSON string from the JSON file into JavaScript objects that could be used in my components.</p><p>To use these two plugins in your Gatsby application, add the following to the plugins section in gatsby-config.js</p><pre>plugins: [<br>   {<br>      resolve: `gatsby-source-filesystem`,<br>      options: {<br>          name: `blog`,<br>          path: `${__dirname}/content/blog/`<br>      },<br>   },<br>   &quot;gatsby-transformer-json&quot;<br>]</pre><p>I finally used the useStaticQuery hook to pull in the JSON data into my Blog component.</p><pre>const data = useStaticQuery(graphql`<br>     query blogDetailList {<br>        allBlogJson {<br>            edges {<br>               node {<br>                  title<br>                  pubDate<br>                  link<br>                  id,<br>                  content_encoded<br>               }<br>            }<br>         }<br>     }<br>`);</pre><p>Here content_encoded will have the entire article data that I used to display the blog content.</p><p><strong>3. Add the node script as part of your deployment process</strong></p><p>As I use Github Pages to deploy my website, I added these two lines into the script section of my package.json so as to make sure to fetch all the latest articles from Medium every time before deploying the website.</p><pre>&quot;scripts&quot;: {<br>    &quot;deploy&quot;: &quot;npm run medium &amp;&amp; gatsby build --prefix-paths &amp;&amp; gh-pages -d public&quot;,<br>    &quot;medium&quot;: &quot;node medium.js&quot;<br>}</pre><p>This helps me keep the articles in my website’s blog section to always be in sync with those on Medium.</p><p>That’s all there is to it!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=749c0932523f\" width=\"1\" height=\"1\">"]}},{"node":{"title":["Code splitting in webpack with dynamic imports"],"pubDate":["Sat, 23 Feb 2019 14:46:16 GMT"],"link":["https://medium.com/@anuhosad/code-splitting-in-webpack-with-dynamic-imports-4385b3760ef8?source=rss-bc5490c02ddb------2"],"id":"8a38a5a7-560d-5527-bcc6-f49016047774","content_encoded":["<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qCiL-PZRJlNW8DnAbHg-4Q.jpeg\" /><figcaption>Photo by <a href=\"https://unsplash.com/photos/taiuG8CPKAQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Max Nelson</a> on <a href=\"https://unsplash.com/search/photos/webpack?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Unsplash</a></figcaption></figure><p>With the advent of package bundlers like webpack, the general tendency is to combine all the JS code into a single bundle.js file. As the app features grow, the size of the bundle.js file grows quickly from mere KBs to MBs. This negatively affects the webpage performance as the user now has to wait for the gigantic bundle.js file to load before they can interact with the page. Most of that code might not even be needed by that user as they may not navigate to that portion of your app.</p><p>Hence it is necessary to split code into multiple chunks. To do this you have to identify the bare minimum code required for the first page load and defer the rest of the code to load only when the user lands on that particular part of your app or a page. This is referred to as “Lazy Loading” your assets.</p><p>In the project that I work on, we use React, <a href=\"https://www.npmjs.com/package/universal-router\">universal-router</a> library for client side routing and webpack (version 2.x). With this setup, here is how we implemented code splitting and lazy loading:</p><ol><li><strong>Add dynamic imports for the various routes of your app</strong></li></ol><p>First thing to do is to indicate to webpack that a particular path in your application code should not be included in the main bundle.js file. This is done via dynamic imports as shown below:</p><pre>/* assuming pageId indicates the page the user is on */</pre><pre>switch (pageId) {<br>    case &quot;login&quot;: <br>        PageComponent = await import(/* webpackChunkName: &quot;login&quot; */ &quot;./pages/user/Login&quot;); <br>        break;<br>    case &quot;home&quot;: <br>        PageComponent = await import(/* webpackChunkName: &quot;home&quot; */ &quot;./pages/home/Home&quot;); <br>        break;<br>    case &quot;profile&quot;: <br>        PageComponent = await import(/* webpackChunkName: &quot;profile&quot; */ &quot;./pages/profile/MyProfile&quot;); <br>        break;<br>    case &quot;assets&quot;: <br>        PageComponent = await import(/* webpackChunkName: &quot;assets&quot; */ &quot;./pages/assets/Assets&quot;); <br>        break;<br>    case &quot;admin&quot;: <br>        PageComponent = await import(/* webpackChunkName: &quot;admin&quot; */ &quot;./pages/admin/Admin&quot;); <br>        break;<br>    default: <br>        PageComponent = Unknown; <br>        break;<br>}</pre><pre>/* render PageComponent */</pre><p>Importing files via the import() function call returns a promise and hence when webpack comes across such statements during its build process, it creates a new chunk for each of the dynamic imports and dumps all the code for that path in the corresponding chunk file.</p><p>The webpackChunkName written in comments above allows you to specify a chunk name for that chunk of code. Without this, webpack would generate random numbers for the chunk name.</p><p>So, this is one part of the problem solved. Now that we have the code for different pages in different bundles or chunks, we need some mechanism to access the correct chunk code for the correct pages. Webpack handles this as well by dynamically creating a script tag and attaching the appropriate chunk file name as the source for the script tag. This code of webpack replaces the dynamic import statement above and hence when the user navigates to a different page the respective chunk file gets loaded.</p><p>Here is the webpack generated code which does this bit for the dynamic imports mentioned above:</p><pre>// This file contains only the entry chunk.<br>// The chunk loading function for additional chunks<br>__webpack_require__.e = function requireEnsure(chunkId) {<br>    var installedChunkData = installedChunks[chunkId];<br>    if (installedChunkData === 0) {<br>        return new Promise(function(resolve) {<br>            resolve();<br>        });<br>    }</pre><pre>    // a Promise means &quot;currently loading&quot;.<br>    if (installedChunkData) {<br>        return installedChunkData[2];<br>    }</pre><pre>    // setup Promise in chunk cache<br>    var promise = new Promise(function(resolve, reject) {<br>        installedChunkData = installedChunks[chunkId] = [resolve, reject];<br>    });<br>    installedChunkData[2] = promise;</pre><pre>    // start chunk loading<br>    var head = document.getElementsByTagName(&#39;head&#39;)[0];<br>    var script = document.createElement(&#39;script&#39;);<br>    script.type = &#39;text/javascript&#39;;<br>    script.charset = &#39;utf-8&#39;;<br>    script.async = true;<br>    script.timeout = 120000;</pre><pre>    if (__webpack_require__.nc) {<br>        script.setAttribute(&quot;nonce&quot;, __webpack_require__.nc);<br>    }</pre><pre><strong>    script.src = __webpack_require__.p + &quot;&quot; + ({&quot;7&quot;: &quot;assets&quot;, &quot;10&quot;: &quot;admin&quot;, &quot;13&quot;: &quot;login&quot;, &quot;14&quot;: &quot;profile&quot;, &quot;15&quot;: &quot;home&quot;}[chunkId] || chunkId) + &quot;.chunk.js&quot;;</strong></pre><pre>    var timeout = setTimeout(onScriptComplete, 120000);<br>    script.onerror = script.onload = onScriptComplete;</pre><pre>    function onScriptComplete() {<br>        // avoid mem leaks in IE.<br>        script.onerror = script.onload = null;<br>        clearTimeout(timeout);<br>        var chunk = installedChunks[chunkId];<br>        if (chunk !== 0) {<br>            if (chunk) {<br>                chunk[1](new Error(&#39;Loading chunk &#39; + chunkId + &#39; failed.&#39;));<br>            }<br>            installedChunks[chunkId] = undefined;<br>        }<br>    };<br>    <br>    head.appendChild(script);</pre><pre>    return promise;<br>};</pre><p>As seen from the code above, webpack is smart enough to cache the chunk data that it has already requested and hence if the user navigates back to the same page, it does not make a new network call but returns from its cache instead.</p><p><strong>2. Include the </strong><a href=\"https://www.npmjs.com/package/babel-plugin-syntax-dynamic-import\"><strong>babel-plugin-syntax-dynamic-import</strong></a><strong> webpack plugin</strong></p><p>Dynamic imports syntax is recently introduced in the language and hence is not a standard yet. So, to make it work with webpack you need to first install the babel-plugin-syntax-dynamic-import package via:</p><pre>npm install --save-dev babel-plugin-syntax-dynamic-import</pre><p>Next, add the syntax-dynamic-import plugin to your webpack.config.js file:</p><pre>const path = require(&#39;path&#39;);<br>const packageJson = require(&quot;./package.json&quot;);</pre><pre>module.exports = {<br>    devtool: &#39;source-map&#39;,<br>    entry: {<br>        bundle: [&#39;babel-polyfill&#39;,&#39;./src/main&#39;],<br>    },<br>    output: {<br>        filename: &#39;[name].js&#39;,<br>        <strong>chunkFilename: `[name].chunk.${packageJson.version}.js`,</strong><br>        path: path.join(__dirname, &#39;public/dist&#39;),<br>        publicPath: &#39;/dist/&#39;<br>    },<br>    resolve:{<br>        extensions:[&#39;.js&#39;]<br>    },<br>    externals:{<br>        &#39;react&#39;:&#39;React&#39;,<br>        &#39;react-dom&#39;:&#39;ReactDOM&#39;<br>    },<br>    module:{<br>        loaders:[<br>            {<br>                test:/\\.js?$/,<br>                loader:&#39;babel-loader&#39;,<br>                query:{<br>                    presets: [&#39;es2015&#39;, &#39;react&#39;, &#39;stage-0&#39;],<br>                    <strong>plugins: [&#39;syntax-dynamic-import&#39;]</strong><br>                },<br>                exclude:/node_modules/<br>            }<br>        ]<br>    }<br>}</pre><p>As seen in the above config, you can also further customise your chunk file name by specifying it in the output key in webpack.config.js file. In this case I am adding the app package version for cache busting.</p><p>That’s all folks. It is this simple to add a quick performance boost to your web application by relying on webpack to do most of the heavy lifting.</p><p>Happy coding :-)</p><p>References:<br><a href=\"https://medium.com/front-end-weekly/lazy-loading-with-react-and-webpack-2-8e9e586cf442\">https://medium.com/front-end-weekly/lazy-loading-with-react-and-webpack-2-8e9e586cf442</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4385b3760ef8\" width=\"1\" height=\"1\">"]}},{"node":{"title":["React Errors : Super expression must either be null or a function"],"pubDate":["Sat, 26 Jan 2019 14:40:50 GMT"],"link":["https://medium.com/@anuhosad/react-errors-super-expression-must-either-be-null-or-a-function-4aac6e5173ad?source=rss-bc5490c02ddb------2"],"id":"0f83a70c-4d4e-556d-897a-bf9dcfc8006d","content_encoded":["<h3>React Errors : <strong><em>Super expression must either be null or a function</em></strong></h3><p>Have you come across this error when working with React?</p><blockquote><strong>Uncaught TypeError: Super expression must either be null or a function, not undefined</strong></blockquote><p>If yes, then this post is for you!</p><p>Lets look at the culprits (that I have come across so far) that cause this error.</p><ol><li><strong>Forgotten export</strong><br>The first culprit is usually that you have forgotten to export the component that you are trying to use and hence React finds that the Component you are trying to extend from is undefined . This is an easy to find and fix��issue.</li><li><strong>Using a default export incorrectly<br></strong>If a component is exported with the default keyword then it must be imported as a default import and not as a named import. <br>For example if your export statement is export default Foo, then the correct way to import this component is import Foo from &quot;./Foo&quot; and not import { Foo } from &quot;./Foo&quot; . The latter import statement is for named exports.</li><li><strong>Circular Dependencies<br></strong>This is a an often missed culprit which I came across recently in one of the projects I was working on. After going into the depths of the google search rabbit hole, I finally came across a stack overflow answer that shed some light on why I was still getting the error inspite of the component being exported / imported correctly.<br>If you have dependencies of a cyclic nature like shown below, it will result in this error:</li></ol><pre>class A extends B {}<br>class B extends C {}<br>class C extends A {}</pre><p>This of-course is a very simple case of a cyclic dependency, but in a medium to large size project it might be hidden deeply in the Component tree and thus hard to find.</p><p>Hope this post helped someone out there pulling their hair out trying to figure out how to solve this issue!</p><p>PS : There is a good chance that the “someone” would be me in the future still getting the same error and forgotten what the causes are :-P</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4aac6e5173ad\" width=\"1\" height=\"1\">"]}}]}}}