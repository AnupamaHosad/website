{
    "title": [
        "A quick intro to async/await in Javascript"
    ],
    "link": [
        "https://medium.com/@anuhosad/a-quick-intro-to-async-await-in-javascript-64dff152a19d?source=rss-bc5490c02ddb------2"
    ],
    "guid": [
        {
            "_": "https://medium.com/p/64dff152a19d",
            "$": {
                "isPermaLink": "false"
            }
        }
    ],
    "category": [
        "javascript-development",
        "asyncawait",
        "javascript",
        "asynchronous",
        "es8"
    ],
    "dc:creator": [
        "Anupama"
    ],
    "pubDate": [
        "Thu, 10 May 2018 11:07:21 GMT"
    ],
    "atom:updated": [
        "2018-05-10T11:14:22.607Z"
    ],
    "content:encoded": [
        "<p>async/await is the latest addition to the language that helps in writing better asynchronous code. It is part of the 8th Edition of ECMAScript (called ES8 or ES2017).</p><p>Before we jump into the details of async/await, let us go back in time to revisit the various approaches to asynchronous programming in javascript.</p><p>Lets take the hypothetical case of customers at a coffee shop. A customer goes up to the counter and orders coffee. They get a token in return for the order and probably go and take a seat at the coffee shop, reading their newspapers or phones or maybe chatting with a friend while they wait for their coffee. Once the coffee is done, the customer gets a notification that their coffee is ready and they go pick it up. While the customer is waiting for his coffee, the person at the counter takes order from the other customers in the queue.<br>The entire process is asynchronous here. The customer orders coffee and then goes back to doing something. The person at the counter takes other orders meanwhile. So waiting for one customer’s coffee to be done does not block the other customers waiting in queue.</p><p>Lets see how to implement this in javascript with the various available features.</p><ol><li><strong>Callback Pattern</strong></li></ol><p>This is one of the basic patterns used to achieving asynchronous behaviour in javascript that works across all environments. In this pattern a function is passed onto the function doing the asynchronous task. Once the asynchronous task is done, the passed function gets called (which is called the callback function).</p><p>Implementing the code for the above problem with callback function would look as follows:</p><pre>function serveCoffee () {<br>    console.log(&quot;Yay! your coffee is done, enjoy!&quot;);<br>}</pre><pre>function makeCoffee (callbackFn) {<br>    /* Simulating coffee making using setTimeout */<br>    setTimeout(function () {<br>       callbackFn();<br>    }, 5000);<br>}</pre><pre>function handleCoffeeOrder () {<br>    /* send request to make the coffee,<br>       serveCoffee is the callback function that gets called once the coffee is ready */<br>    makeCoffee(serveCoffee); <br>}</pre><pre>handleCoffeeOrder(); /* handle coffee order from a customer */</pre><p>In the code above, serveCoffee is the callback function that gets called once the coffee is prepared.</p><p>This pattern gets messy with nested asynchronous calls. The problem is often referred to as <em>callback hell</em> or <em>Christmas tree problem</em> ( because it kind of looks like a fallen down Christmas tree!)</p><pre>doAsyncTask1(function() {<br>  doAsyncTask2(function() {<br>    doAsyncTask3(function() {<br>      doAsyncTask4(function() {<br>        console.log(&quot;Finally Done!&quot;);<br>      });<br>    });<br>  });<br>});</pre><p><strong>2. Promises</strong></p><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promises</a> was introduced in ES6 (or ES2015). This provided a better mechanism to handle asynchronous tasks than using callbacks.</p><p>Implementing the solution for the coffee task using promises would be as follows:</p><pre>function makeCoffee (onCoffeeDone) {<br>    <strong>return new Promise(resolve, reject) {</strong><br>        /* Simulating coffee making using setTimeout */<br>        setTimeout(function() {<br>            <strong>resolve(&quot;success&quot;);</strong><br>        }, 2000);<br>    <strong>};</strong><br>}</pre><pre>function handleCoffeeOrder () {<br>    makeCoffee()<br>    .then(function () {<br>        serveCoffee();<br>    });<br>}</pre><pre>handleCoffeeOrder();</pre><p>Here, in the makeCoffee function, a Promise object is created and returned. Once the task is done (here it is preparing the coffee), resolve function is called which indicates that the task is done successfully. Once the promise is resolved, code in the then block gets executed.</p><p>The above code looks a little neater than the callback pattern code and is easier to reason with.</p><p>The nested asynchronous calls problem looks like below with promises:</p><pre>doAsyncTask1().then(function () {<br>   return doAsyncTask2();<br>}).then(function () {<br>   return doAsyncTask3();<br>}).then(function () {<br>   return doAsyncTask4();<br>}).then(function () {<br>   console.log(&quot;Finally Done!&quot;);<br>});</pre><p><strong>3. async/await</strong></p><p>The same logic above can be written as shown below with async/await:</p><pre>function makeCoffee (onCoffeeDone) {<br>    return new Promise(resolve, reject) {<br>        /* Simulating coffee making using setTimeout */<br>        setTimeout(function () {<br>            resolve(&quot;success&quot;);<br>        }, 2000);<br>    };<br>}</pre><pre><strong>async</strong> function handleCoffeeOrder () {<br>   let response = <strong>await</strong> makeCoffee();<br>   serveCoffee();<br>}</pre><pre>handleCoffeeOrder();</pre><p>To begin with, any function that is asynchronous should be marked with the <strong>async</strong> keyword. You can then use the <strong>await</strong> keyword to wait for an asynchronous task (i.e. any function that returns a Promise). What this essentially does is pauses the function execution until the asynchronous task finishes. However, the rest of the Javascript execution continues and is not blocked. That means in this case, while “awaiting” for one customer’s coffee to be done, the person at the counter can take in more orders and make more requests for coffee.</p><p>One thing to note here is that a function marked async also returns a Promise which gets resolved when the function completes execution and returns a value.</p><p>The nested asynchronous calls problem looks like below with async/await:</p><pre>async function performAsyncTasks () {<br>   await doAsyncTask1();<br>   await doAsyncTask2();<br>   await doAsyncTask3();<br>   await doAsyncTask4();<br>   console.log(&quot;Finally Done!&quot;);<br>}</pre><p>As seen from the code above, async/await provides a much cleaner way to write asynchronous code in a “synchronous looking” manner. The number of lines of code is also much lesser than using promises or callback functions.</p><p>Finally, here is the current browser support matrix for async/await :</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*9hOlRmx9ZefDMCMQERHUbg.png\" /><figcaption><strong>Reference:</strong> <a href=\"https://caniuse.com/#search=await\">https://caniuse.com/#search=await</a></figcaption></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=64dff152a19d\" width=\"1\" height=\"1\">"
    ]
}