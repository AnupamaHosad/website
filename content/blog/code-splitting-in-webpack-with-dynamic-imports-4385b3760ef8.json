{
    "title": [
        "Code splitting in webpack with dynamic imports"
    ],
    "link": [
        "https://medium.com/@anuhosad/code-splitting-in-webpack-with-dynamic-imports-4385b3760ef8?source=rss-bc5490c02ddb------2"
    ],
    "guid": [
        {
            "_": "https://medium.com/p/4385b3760ef8",
            "$": {
                "isPermaLink": "false"
            }
        }
    ],
    "category": [
        "lazy-loading",
        "code-splitting",
        "webpack-2",
        "javascript",
        "dynamic-import"
    ],
    "dc:creator": [
        "Anupama"
    ],
    "pubDate": [
        "Sat, 23 Feb 2019 14:46:16 GMT"
    ],
    "atom:updated": [
        "2019-03-01T06:12:15.613Z"
    ],
    "content:encoded": [
        "<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qCiL-PZRJlNW8DnAbHg-4Q.jpeg\" /><figcaption>Photo by <a href=\"https://unsplash.com/photos/taiuG8CPKAQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Max Nelson</a> on <a href=\"https://unsplash.com/search/photos/webpack?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Unsplash</a></figcaption></figure><p>With the advent of package bundlers like webpack, the general tendency is to combine all the JS code into a single bundle.js file. As the app features grow, the size of the bundle.js file grows quickly from mere KBs to MBs. This negatively affects the webpage performance as the user now has to wait for the gigantic bundle.js file to load before they can interact with the page. Most of that code might not even be needed by that user as they may not navigate to that portion of your app.</p><p>Hence it is necessary to split code into multiple chunks. To do this you have to identify the bare minimum code required for the first page load and defer the rest of the code to load only when the user lands on that particular part of your app or a page. This is referred to as “Lazy Loading” your assets.</p><p>In the project that I work on, we use React, <a href=\"https://www.npmjs.com/package/universal-router\">universal-router</a> library for client side routing and webpack (version 2.x). With this setup, here is how we implemented code splitting and lazy loading:</p><ol><li><strong>Add dynamic imports for the various routes of your app</strong></li></ol><p>First thing to do is to indicate to webpack that a particular path in your application code should not be included in the main bundle.js file. This is done via dynamic imports as shown below:</p><pre>/* assuming pageId indicates the page the user is on */</pre><pre>switch (pageId) {<br>    case &quot;login&quot;: <br>        PageComponent = await import(/* webpackChunkName: &quot;login&quot; */ &quot;./pages/user/Login&quot;); <br>        break;<br>    case &quot;home&quot;: <br>        PageComponent = await import(/* webpackChunkName: &quot;home&quot; */ &quot;./pages/home/Home&quot;); <br>        break;<br>    case &quot;profile&quot;: <br>        PageComponent = await import(/* webpackChunkName: &quot;profile&quot; */ &quot;./pages/profile/MyProfile&quot;); <br>        break;<br>    case &quot;assets&quot;: <br>        PageComponent = await import(/* webpackChunkName: &quot;assets&quot; */ &quot;./pages/assets/Assets&quot;); <br>        break;<br>    case &quot;admin&quot;: <br>        PageComponent = await import(/* webpackChunkName: &quot;admin&quot; */ &quot;./pages/admin/Admin&quot;); <br>        break;<br>    default: <br>        PageComponent = Unknown; <br>        break;<br>}</pre><pre>/* render PageComponent */</pre><p>Importing files via the import() function call returns a promise and hence when webpack comes across such statements during its build process, it creates a new chunk for each of the dynamic imports and dumps all the code for that path in the corresponding chunk file.</p><p>The webpackChunkName written in comments above allows you to specify a chunk name for that chunk of code. Without this, webpack would generate random numbers for the chunk name.</p><p>So, this is one part of the problem solved. Now that we have the code for different pages in different bundles or chunks, we need some mechanism to access the correct chunk code for the correct pages. Webpack handles this as well by dynamically creating a script tag and attaching the appropriate chunk file name as the source for the script tag. This code of webpack replaces the dynamic import statement above and hence when the user navigates to a different page the respective chunk file gets loaded.</p><p>Here is the webpack generated code which does this bit for the dynamic imports mentioned above:</p><pre>// This file contains only the entry chunk.<br>// The chunk loading function for additional chunks<br>__webpack_require__.e = function requireEnsure(chunkId) {<br>    var installedChunkData = installedChunks[chunkId];<br>    if (installedChunkData === 0) {<br>        return new Promise(function(resolve) {<br>            resolve();<br>        });<br>    }</pre><pre>    // a Promise means &quot;currently loading&quot;.<br>    if (installedChunkData) {<br>        return installedChunkData[2];<br>    }</pre><pre>    // setup Promise in chunk cache<br>    var promise = new Promise(function(resolve, reject) {<br>        installedChunkData = installedChunks[chunkId] = [resolve, reject];<br>    });<br>    installedChunkData[2] = promise;</pre><pre>    // start chunk loading<br>    var head = document.getElementsByTagName(&#39;head&#39;)[0];<br>    var script = document.createElement(&#39;script&#39;);<br>    script.type = &#39;text/javascript&#39;;<br>    script.charset = &#39;utf-8&#39;;<br>    script.async = true;<br>    script.timeout = 120000;</pre><pre>    if (__webpack_require__.nc) {<br>        script.setAttribute(&quot;nonce&quot;, __webpack_require__.nc);<br>    }</pre><pre><strong>    script.src = __webpack_require__.p + &quot;&quot; + ({&quot;7&quot;: &quot;assets&quot;, &quot;10&quot;: &quot;admin&quot;, &quot;13&quot;: &quot;login&quot;, &quot;14&quot;: &quot;profile&quot;, &quot;15&quot;: &quot;home&quot;}[chunkId] || chunkId) + &quot;.chunk.js&quot;;</strong></pre><pre>    var timeout = setTimeout(onScriptComplete, 120000);<br>    script.onerror = script.onload = onScriptComplete;</pre><pre>    function onScriptComplete() {<br>        // avoid mem leaks in IE.<br>        script.onerror = script.onload = null;<br>        clearTimeout(timeout);<br>        var chunk = installedChunks[chunkId];<br>        if (chunk !== 0) {<br>            if (chunk) {<br>                chunk[1](new Error(&#39;Loading chunk &#39; + chunkId + &#39; failed.&#39;));<br>            }<br>            installedChunks[chunkId] = undefined;<br>        }<br>    };<br>    <br>    head.appendChild(script);</pre><pre>    return promise;<br>};</pre><p>As seen from the code above, webpack is smart enough to cache the chunk data that it has already requested and hence if the user navigates back to the same page, it does not make a new network call but returns from its cache instead.</p><p><strong>2. Include the </strong><a href=\"https://www.npmjs.com/package/babel-plugin-syntax-dynamic-import\"><strong>babel-plugin-syntax-dynamic-import</strong></a><strong> webpack plugin</strong></p><p>Dynamic imports syntax is recently introduced in the language and hence is not a standard yet. So, to make it work with webpack you need to first install the babel-plugin-syntax-dynamic-import package via:</p><pre>npm install --save-dev babel-plugin-syntax-dynamic-import</pre><p>Next, add the syntax-dynamic-import plugin to your webpack.config.js file:</p><pre>const path = require(&#39;path&#39;);<br>const packageJson = require(&quot;./package.json&quot;);</pre><pre>module.exports = {<br>    devtool: &#39;source-map&#39;,<br>    entry: {<br>        bundle: [&#39;babel-polyfill&#39;,&#39;./src/main&#39;],<br>    },<br>    output: {<br>        filename: &#39;[name].js&#39;,<br>        <strong>chunkFilename: `[name].chunk.${packageJson.version}.js`,</strong><br>        path: path.join(__dirname, &#39;public/dist&#39;),<br>        publicPath: &#39;/dist/&#39;<br>    },<br>    resolve:{<br>        extensions:[&#39;.js&#39;]<br>    },<br>    externals:{<br>        &#39;react&#39;:&#39;React&#39;,<br>        &#39;react-dom&#39;:&#39;ReactDOM&#39;<br>    },<br>    module:{<br>        loaders:[<br>            {<br>                test:/\\.js?$/,<br>                loader:&#39;babel-loader&#39;,<br>                query:{<br>                    presets: [&#39;es2015&#39;, &#39;react&#39;, &#39;stage-0&#39;],<br>                    <strong>plugins: [&#39;syntax-dynamic-import&#39;]</strong><br>                },<br>                exclude:/node_modules/<br>            }<br>        ]<br>    }<br>}</pre><p>As seen in the above config, you can also further customise your chunk file name by specifying it in the output key in webpack.config.js file. In this case I am adding the app package version for cache busting.</p><p>That’s all folks. It is this simple to add a quick performance boost to your web application by relying on webpack to do most of the heavy lifting.</p><p>Happy coding :-)</p><p>References:<br><a href=\"https://medium.com/front-end-weekly/lazy-loading-with-react-and-webpack-2-8e9e586cf442\">https://medium.com/front-end-weekly/lazy-loading-with-react-and-webpack-2-8e9e586cf442</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4385b3760ef8\" width=\"1\" height=\"1\">"
    ]
}